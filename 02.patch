diff --git a/drivers/hid/usbhid/Kconfig b/drivers/hid/usbhid/Kconfig
index 0108c59..32aa3a2 100644
--- a/drivers/hid/usbhid/Kconfig
+++ b/drivers/hid/usbhid/Kconfig
@@ -3,7 +3,7 @@ menu "USB HID support"
 
 config USB_HID
 	tristate "USB HID transport layer"
-	default y
+	default m
 	depends on USB && INPUT
 	select HID
 	---help---
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 0df32fe..43befef 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -266,6 +266,10 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
  * Input interrupt completion handler.
  */
 
+#include <linux/usb/gadget.h>
+extern struct usb_request *hidg_alloc_in_ep_req(unsigned length);
+extern ssize_t hidg_write_report(struct usb_request *req, size_t count);
+
 static void hid_irq_in(struct urb *urb)
 {
 	struct hid_device	*hid = urb->context;
@@ -291,6 +295,19 @@ static void hid_irq_in(struct urb *urb)
 				set_bit(HID_KEYS_PRESSED, &usbhid->iofl);
 			else
 				clear_bit(HID_KEYS_PRESSED, &usbhid->iofl);
+
+			if (8 == urb->actual_length) {
+				int status_gadget;
+				u8 *data = (u8 *)urb->transfer_buffer;
+				struct usb_request	*req;
+
+				req = hidg_alloc_in_ep_req(urb->actual_length);
+				memcpy(req->buf, data, urb->actual_length);
+				status_gadget = hidg_write_report(req, urb->actual_length);
+
+				/* pr_info("xbing: %s: actual_length = %d, buffer = 0x%2x, 0x%2x, 0x%2x", \
+								__func__, urb->actual_length, data[0], data[1], data[2]); */
+			}
 		}
 		break;
 	case -EPIPE:		/* stall */
diff --git a/drivers/usb/gadget/function/f_hid.c b/drivers/usb/gadget/function/f_hid.c
index 99285b4..5944ec8 100644
--- a/drivers/usb/gadget/function/f_hid.c
+++ b/drivers/usb/gadget/function/f_hid.c
@@ -73,6 +73,8 @@ static inline struct f_hidg *func_to_hidg(struct usb_function *f)
 	return container_of(f, struct f_hidg, func);
 }
 
+struct f_hidg *g_hidg;
+
 /*-------------------------------------------------------------------------*/
 /*                           Static descriptors                            */
 
@@ -265,6 +267,32 @@ static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
 	wake_up(&hidg->write_queue);
 }
 
+ssize_t hidg_write_report(struct usb_request *req, size_t count)
+{
+	struct f_hidg *hidg  = g_hidg;
+	ssize_t status = -ENOMEM;
+
+	req->status   = 0;
+	req->zero     = 0;
+	req->length   = count;
+	req->complete = f_hidg_req_complete;
+	req->context  = hidg;
+	hidg->write_pending = 1;
+
+	status = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);
+	if (status < 0) {
+		ERROR(hidg->func.config->cdev,
+			"usb_ep_queue error on int endpoint %zd\n", status);
+		hidg->write_pending = 0;
+		wake_up(&hidg->write_queue);
+	} else {
+		status = count;
+	}
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(hidg_write_report);
+
 static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 			    size_t count, loff_t *offp)
 {
@@ -301,22 +329,7 @@ static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
 		return -EINVAL;
 	}
 
-	hidg->req->status   = 0;
-	hidg->req->zero     = 0;
-	hidg->req->length   = count;
-	hidg->req->complete = f_hidg_req_complete;
-	hidg->req->context  = hidg;
-	hidg->write_pending = 1;
-
-	status = usb_ep_queue(hidg->in_ep, hidg->req, GFP_ATOMIC);
-	if (status < 0) {
-		ERROR(hidg->func.config->cdev,
-			"usb_ep_queue error on int endpoint %zd\n", status);
-		hidg->write_pending = 0;
-		wake_up(&hidg->write_queue);
-	} else {
-		status = count;
-	}
+	status = hidg_write_report(hidg->req, count);
 
 	mutex_unlock(&hidg->lock);
 
@@ -368,6 +381,12 @@ static inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,
 	return alloc_ep_req(ep, length, length);
 }
 
+struct usb_request *hidg_alloc_in_ep_req(unsigned length)
+{
+	return alloc_ep_req(g_hidg->in_ep, length, length);
+}
+EXPORT_SYMBOL_GPL(hidg_alloc_in_ep_req);
+
 static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_hidg *hidg = (struct f_hidg *) req->context;
@@ -922,9 +941,10 @@ static struct usb_function *hidg_alloc(struct usb_function_instance *fi)
 	struct f_hid_opts *opts;
 
 	/* allocate and initialize one new instance */
-	hidg = kzalloc(sizeof(*hidg), GFP_KERNEL);
-	if (!hidg)
+	g_hidg = kzalloc(sizeof(*hidg), GFP_KERNEL);
+	if (!g_hidg)
 		return ERR_PTR(-ENOMEM);
+	hidg = g_hidg;
 
 	opts = container_of(fi, struct f_hid_opts, func_inst);
 
diff --git a/drivers/usb/gadget/legacy/hid.c b/drivers/usb/gadget/legacy/hid.c
index 7e5d2c4..f088fcb 100644
--- a/drivers/usb/gadget/legacy/hid.c
+++ b/drivers/usb/gadget/legacy/hid.c
@@ -23,6 +23,7 @@
 #define DRIVER_VERSION		"2010/03/16"
 
 #include "u_hid.h"
+#include "../function/u_hid.c"
 
 /*-------------------------------------------------------------------------*/
 
@@ -280,6 +281,12 @@ static int __init hidg_init(void)
 {
 	int status;
 
+	status = platform_device_register(&my_hid);
+	if (status < 0) {
+		pr_err("%s: platform_device_register fail! \n", __func__);
+		return status;
+	}
+
 	status = platform_driver_probe(&hidg_plat_driver,
 				hidg_plat_driver_probe);
 	if (status < 0)
@@ -295,6 +302,7 @@ module_init(hidg_init);
 
 static void __exit hidg_cleanup(void)
 {
+	platform_device_unregister(&my_hid);
 	usb_composite_unregister(&hidg_driver);
 	platform_driver_unregister(&hidg_plat_driver);
 }
diff --git a/drivers/usb/gadget/function/u_hid.c b/drivers/usb/gadget/function/u_hid.c
new file mode 100644
index 0000000..8d1ec0d
--- /dev/null
+++ b/drivers/usb/gadget/function/u_hid.c
@@ -0,0 +1,57 @@
+#include <linux/platform_device.h>
+#include <linux/usb/g_hid.h>
+
+/* hid descriptor for a keyboard */
+static struct hidg_func_descriptor my_hid_data = {
+	.subclass		= 0, /* No subclass */
+	.protocol		= 1, /* Keyboard */
+	.report_length		= 8,
+	.report_desc_length	= 63,
+	.report_desc		= {
+		0x05, 0x01,	/* USAGE_PAGE (Generic Desktop)	          */
+		0x09, 0x06,	/* USAGE (Keyboard)                       */
+		0xa1, 0x01,	/* COLLECTION (Application)               */
+		0x05, 0x07,	/*   USAGE_PAGE (Keyboard)                */
+		0x19, 0xe0,	/*   USAGE_MINIMUM (Keyboard LeftControl) */
+		0x29, 0xe7,	/*   USAGE_MAXIMUM (Keyboard Right GUI)   */
+		0x15, 0x00,	/*   LOGICAL_MINIMUM (0)                  */
+		0x25, 0x01,	/*   LOGICAL_MAXIMUM (1)                  */
+		0x75, 0x01,	/*   REPORT_SIZE (1)                      */
+		0x95, 0x08,	/*   REPORT_COUNT (8)                     */
+		0x81, 0x02,	/*   INPUT (Data,Var,Abs)                 */
+		0x95, 0x01,	/*   REPORT_COUNT (1)                     */
+		0x75, 0x08,	/*   REPORT_SIZE (8)                      */
+		0x81, 0x03,	/*   INPUT (Cnst,Var,Abs)                 */
+		0x95, 0x05,	/*   REPORT_COUNT (5)                     */
+		0x75, 0x01,	/*   REPORT_SIZE (1)                      */
+		0x05, 0x08,	/*   USAGE_PAGE (LEDs)                    */
+		0x19, 0x01,	/*   USAGE_MINIMUM (Num Lock)             */
+		0x29, 0x05,	/*   USAGE_MAXIMUM (Kana)                 */
+		0x91, 0x02,	/*   OUTPUT (Data,Var,Abs)                */
+		0x95, 0x01,	/*   REPORT_COUNT (1)                     */
+		0x75, 0x03,	/*   REPORT_SIZE (3)                      */
+		0x91, 0x03,	/*   OUTPUT (Cnst,Var,Abs)                */
+		0x95, 0x06,	/*   REPORT_COUNT (6)                     */
+		0x75, 0x08,	/*   REPORT_SIZE (8)                      */
+		0x15, 0x00,	/*   LOGICAL_MINIMUM (0)                  */
+		0x25, 0x65,	/*   LOGICAL_MAXIMUM (101)                */
+		0x05, 0x07,	/*   USAGE_PAGE (Keyboard)                */
+		0x19, 0x00,	/*   USAGE_MINIMUM (Reserved)             */
+		0x29, 0x65,	/*   USAGE_MAXIMUM (Keyboard Application) */
+		0x81, 0x00,	/*   INPUT (Data,Ary,Abs)                 */
+		0xc0		/* END_COLLECTION                         */
+	}
+};
+
+static void my_hid_dev_release(struct device *dev)
+{
+}
+
+static struct platform_device my_hid = {
+	.name			= "hidg",
+	.id			= 0,
+	.num_resources		= 0,
+	.resource		= 0,
+	.dev.platform_data	= &my_hid_data,
+	.dev.release		= my_hid_dev_release,
+};
